'''

for x in "banana" :
    print (x)

# why does this work for an undefined variable?
# for every numbered index of the array of 'banana'?

when might you need to do bitwise shift assignments?
eg.

x >>= y
shifts all bits in x by one and assigns that bit value to y

need to understand :=, it seems super powerful
need to understand 'in' and 'not in'

list1 = [i for i in range(1,6)]

#this is not code below
expression FOR item IN iterable if condition
expression is evaluated for each item in the iterable
for item in iterable loops over each item in the iterable
the iterable here being the range from 1-6

so in [i for i in range(1,6)]
The initial 'i' is the expression that gets evaluated and included in the resulting list
1. for i in range(1,6) means iterate over the sequence generated by the range(1,6), which is 1-5
2. the i before the for keyword is the expression that is evaluated for each element in the
    iterable range
3. the results of the expression 'i' for each iteration are collected into a new list

for x in y (as well as for loops in general)
only applies while y is of some kind of pseudo-array type, or 'iterable' being:

a list, dictionary, tuple, range, strings (being a list of letters), sets,
generators/iterators (being objects that use __iter__ and __next__ methods,)
or files that it will iterate over line by line (files being a type of object handling
for text)

'''
'''
class MyIterable:
    def __init__(self, max):
        self.max = max
        self.current = 0
    #when this class is initialized, set the 'max' held internally to max and self.current to 0
    #this intializes both variables within the class

    def __iter__(self):
        return self
    #This function is telling the interpreter that this class is iterable - magic function

    def __next__(self):
        if self.current < self.max:
            self.current += 1
            return self.current
        else:
            raise StopIteration
        # StopIteration is a pre-programmed python exception that the interpreter reads as meaning
        # 'this iteration is now complete', sort of like a 'break' in the for x in y loop
        # it will not work however, you are not 'looping' this stupid, because it's a 
        # different 'iterable' case (see above)

my_iterable = MyIterable(3)
# Create an instance of MyIterable with max=3

for num in my_iterable:
    print(num)

# Iterate over the instance
'''
# Define the card numbers and suits
InitCardNum = [str(i) for i in range(1, 11)] + ['Jack', 'Queen', 'King', 'Ace']
InitCardSuit = ['Hearts', 'Diamonds', 'Clubs', 'Spades']

def EstablishCardHierarchy():
    """
    Establish and return card numeric and suit hierarchies.
    """
    TempCardNumValue = {num: i + 1 for i, num in enumerate(InitCardNum)}
    TempCardSuitValue = {suit: i + 1 for i, suit in enumerate(InitCardSuit)}
    
    return TempCardNumValue, TempCardSuitValue

def SimpleEvaluateCards(Card1, Card2):
    """
    Compare two cards based on their numeric values for face and suit.
    
    Parameters:
    Card1 (tuple): A tuple where Card1[0] is the card number and Card1[1] is the card suit.
    Card2 (tuple): A tuple where Card2[0] is the card number and Card2[1] is the card suit.
    
    Returns:
    int: Returns 1 if Card1 is better, -1 if Card2 is better, and 0 if they are equal.
    """
    # Get hierarchies
    CardNumHierarchy, CardSuitHierarchy = EstablishCardHierarchy()  #!!! 
    
    # Extract card values
    Num1, Suit1 = Card1
    Num2, Suit2 = Card2
    
    # Compare suits first
    if CardSuitHierarchy[Suit1] > CardSuitHierarchy[Suit2]:  #!!! 
        return 1
    elif CardSuitHierarchy[Suit1] < CardSuitHierarchy[Suit2]:  #!!! 
        return -1
    else:
        # Suits are the same, compare numbers
        if CardNumHierarchy[Num1] > CardNumHierarchy[Num2]:  #!!! 
            return 1
        elif CardNumHierarchy[Num1] < CardNumHierarchy[Num2]:  #!!! 
            return -1
        else:
            return 0

# Example usage
Card1 = ('Queen', 'Hearts')
Card2 = ('King', 'Diamonds')

result = SimpleEvaluateCards(Card1, Card2)

if result == 1:
    print(f"{Card1} is better than {Card2}")
elif result == -1:
    print(f"{Card2} is better than {Card1}")
else:
    print(f"{Card1} and {Card2} are equal")
